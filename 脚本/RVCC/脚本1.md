```json
"args": ["-o", "/home/zazzle/Zazzle-rvcc/tmp.s", "/home/zazzle/Zazzle-rvcc/tmp.c"],
```



### 视频1

大家好，我准备出一个系列视频讲解一下 rvcc 编译器这个项目

我自己也是边学边写，写的过程中有一些体会，然后做个视频记录一下，当然视频中难免有错误的地方

可以评论区随时讨论





首先 rvcc 是一个编译器项目，它是运行在 x86 平台的，把 C 程序编译为在 RISCV64 平台运行的汇编语句，之前做过一个环境配置的视频可以参考



在深入讲 rvcc 的每个 commit 之前，我觉得必须先从宏观角度认识一下编译器



编译器的基本结构很简单，词法，语法，代码生成，

重点是每个步骤所处理的数据的类型



从词法分析的角度，输入是字符，字符串，输出也是字符，字符串

中间可能需要判断一些 if else 这样的关键字，但是处理对象就是字符串，总体是比较简单的



到语法分析阶段，这个阶段比较复杂，你需要构造一个语法树，这里面有函数，有类型，有数据

还有语法解析的先后顺序，但是核心是把顺序读取的字符组织成一棵树，每一个结点都是一个操作步骤， 并用类型把他们包装起来，传递到后面



在代码生成阶段，我觉得是初期有一些迷惑的地方，所谓的类型在代码生成阶段是没有意义的，它们只能起到合法性的判断作用，唯一的处理对象只有字节，你的操作工具只有寄存器，一切都是字节在栈空间和寄存器的辗转腾挪



除了这些宏观上的认识，在跟着写每个 commit 的时候，我觉得不断提出问题是很重要的

因为 chibicc 作为一个学习项目特殊性，它不是一个真实的，根据需求去实现的项目

很多地方的实现要等到很后面才能体现出来，导致初期看到某个东西会很迷惑但是到后面会突然产生作用

所以我觉得提出问题，质问一个变量存在的意义或者一个初始化值的设定，是很重要

我也从这种方式学到了很多



那么这个视频就到这里，后面开始针对 commit 讲解，不一定每个都讲，我应该挑一些重点



### 视频2

嗨大家好，这次来说一下 rvcc 项目 commit[1] 到 commit[4] 的部分，此时编译器的输入输出通过控制台进行，并且结构不独立所以一起说



我们先来看 commit1，

```
commit1
commit1 的内容很简单 把控制台输入的立即数写到寄存器中
如果要判断  就是把词法分析和语法分析都融合在这个 argc 判断中
然后是 C 的传参格式需要了解一下  argc 是传参的个数 包含自己 比如 ./rvcc 42 两个参数
所以这里的合法性判断是 2

commit2
进行简单的加减运算 根据对符号的判断  执行不同的汇编生成  虽然 commit2 比较混乱  但是能感受到编译过程
虽然整个 while 循环包含词法语法分析和代码生成  但是详细去看  这里其实开始独立了
同时也有简单的词法错误提示  语法错误提示

commit3
支持带空格的运算式的编译
在这次的 commit 中首次把词法分析部分抽离出来  通过词法分析函数来支持含空格的表达式
这里针对词法分析的数据结构非常重要  从上一个视频的宏观层次我们知道词法分析是读取字符输出 token
所以 token 的s

commit4
在词法部分进行了报错信息的优化  errorAt() 注意它处理的层次  注定了它只能用在 tokenize() 层
而 skip() getNumber() 这种参数是 Token 类型的就是 parser 语法分析层
所以说明确层次和它们处理的对象很重要
```

后面，从 commit[4] 开始就有完整的编译器结构了，也逐渐难起来了，会慢慢做视频



### 视频3

嗨大家好，这次来讲讲 commit[5] 的内容

在这个 commit 中实现了一个完整的编译器结构，从词法分析 tokenize 到语法分析 Parse 最后到代码生成 codeGen

所以我也把自己的代码分成了 3 块，这样看的更清晰



在看结构之前，我把这两个报错函数放在了工具函数的位置，之所以会有两个报错函数纯粹是因为需求的场景不同，有的情况需要给出具体报错位置，有的情况不需要，所以定义了两个



然后我们进入具体结构



首先是词法分析的部分，和之前没有什么变化，注意报错函数执行的层次

在处理符号的地方修改为调用 C 库函数  因为涉及到了更多的符号，在后续慢慢复杂起来的时候，比如 数组的方括号，花括号等等符号都可以判断



然后来到语法分析部分，在开始语法分析之前，我们先要知道我们在分析什么，代码语句可以分成两个类型，声明语句和运算语句，我可以声明一个变量，也可以执行两个变量的加法操作

运算语句可能需要修改寄存器或者修改内存，但是声明语句不一定需要，或者说，编译器会先记录这个变量，如果你不使用这个被声明的变量，它其实只是一行死代码，在成熟的编译器上会被直接优化掉



如果声明语句不需要修改寄存器或者内存，那么声明语句是无法被翻译到汇编语句的，因为汇编语句一定是计算语句，对寄存器和内存进行各种各样的操作，当然声明语句不是没有用，后续很快就会涉及，是和类型强相关的



但是现在，看回来，我们知道了语法分析是分两种可能性的，目前的 rvcc 编译器只支持运算语句的解析，所以目前的数据结构都是从运算语句的角度去分析，设计的



我们知道语法分析的输出一定是抽象语法树，抽象语法树又是由各种操作结点构成，最终抽象语法树被传递到代码生成，翻译为汇编语句，既然节点可以被翻译为汇编语句，说明这些结点一定是代表着计算的结点

这些结点代表的操作类型我们从两个方面去理解 。。。 念注释



然后这些操作结点本身又会记录一些额外数据

然后会有一些结点结构的定义



然后来到了很重要的一部分，语法分析过程，目前的运算规则是加减乘除和括号优先级运算

每一个函数都是一个语法规则，自顶向下，优先级依次升高

> 需要插入演示过程

如果不是很熟悉的话，可以多 debug 几次，多看几次就好了



在你看语法规则函数的时候，不知道你会不会有这个问题，在函数递归调用的过程中，`rest` 究竟有什么作用

我们可以重新 debug 一遍看看

> 看一下 rest 功能，主要是保持传递，目前没有任何用，但是可以想想它会有什么用



看完了语法分析，来到了最后的代码生成

针对语法分析中定义的操作结点进行汇编代码生成，类似于栈计算